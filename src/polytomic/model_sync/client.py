# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .targets.client import TargetsClient
from .executions.client import ExecutionsClient
from ..core.request_options import RequestOptions
from ..types.get_model_sync_source_meta_envelope import GetModelSyncSourceMetaEnvelope
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from ..types.api_error import ApiError as types_api_error_ApiError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.rest_err_response import RestErrResponse
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_found_error import NotFoundError
from ..errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError as core_api_error_ApiError
from ..types.model_field_response import ModelFieldResponse
from ..types.model_sync_mode import ModelSyncMode
from ..types.list_model_sync_response_envelope import ListModelSyncResponseEnvelope
from ..types.model_sync_field import ModelSyncField
from ..types.schedule import Schedule
from ..types.target import Target
from ..types.filter import Filter
from ..types.identity import Identity
from ..types.override import Override
from ..types.model_sync_response_envelope import ModelSyncResponseEnvelope
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.schedule_option_response_envelope import ScheduleOptionResponseEnvelope
from ..errors.conflict_error import ConflictError
from ..types.activate_sync_envelope import ActivateSyncEnvelope
from ..types.cancel_model_sync_response_envelope import CancelModelSyncResponseEnvelope
from ..types.start_model_sync_response_envelope import StartModelSyncResponseEnvelope
from ..types.sync_status_envelope import SyncStatusEnvelope
from ..core.client_wrapper import AsyncClientWrapper
from .targets.client import AsyncTargetsClient
from .executions.client import AsyncExecutionsClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ModelSyncClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.targets = TargetsClient(client_wrapper=self._client_wrapper)
        self.executions = ExecutionsClient(client_wrapper=self._client_wrapper)

    def get_source(
        self,
        id: str,
        *,
        params: typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetModelSyncSourceMetaEnvelope:
        """
        Parameters
        ----------
        id : str

        params : typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetModelSyncSourceMetaEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.get_source(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/connections/{jsonable_encoder(id)}/modelsync/source",
            method="GET",
            params={
                "params": params,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetModelSyncSourceMetaEnvelope,
                    parse_obj_as(
                        type_=GetModelSyncSourceMetaEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def get_source_fields(
        self,
        id: str,
        *,
        params: typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelFieldResponse:
        """
        Parameters
        ----------
        id : str

        params : typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelFieldResponse
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.get_source_fields(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/connections/{jsonable_encoder(id)}/modelsync/source/fields",
            method="GET",
            params={
                "params": params,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelFieldResponse,
                    parse_obj_as(
                        type_=ModelFieldResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def list(
        self,
        *,
        active: typing.Optional[bool] = None,
        mode: typing.Optional[ModelSyncMode] = None,
        target_connection_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListModelSyncResponseEnvelope:
        """
        Parameters
        ----------
        active : typing.Optional[bool]

        mode : typing.Optional[ModelSyncMode]

        target_connection_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListModelSyncResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.list(
            active=True,
            target_connection_id="0b155265-c537-44c9-9359-a3ceb468a4da",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/syncs",
            method="GET",
            params={
                "active": active,
                "mode": mode,
                "target_connection_id": target_connection_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=ListModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        fields: typing.Sequence[ModelSyncField],
        mode: ModelSyncMode,
        name: str,
        schedule: Schedule,
        target: Target,
        active: typing.Optional[bool] = OMIT,
        encryption_passphrase: typing.Optional[str] = OMIT,
        filter_logic: typing.Optional[str] = OMIT,
        filters: typing.Optional[typing.Sequence[Filter]] = OMIT,
        identity: typing.Optional[Identity] = OMIT,
        only_enrich_updates: typing.Optional[bool] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        override_fields: typing.Optional[typing.Sequence[ModelSyncField]] = OMIT,
        overrides: typing.Optional[typing.Sequence[Override]] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        skip_initial_backfill: typing.Optional[bool] = OMIT,
        sync_all_records: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelSyncResponseEnvelope:
        """
        Create a new sync from one or more models to a destination.

        All of the functionality described in [the product
        documentation](https://docs.polytomic.com/docs/sync-destinations) is
        configurable via the API.

        Guides:

        - [Model sync (Reverse ETL) from Snowflake query to Salesforce](https://apidocs.polytomic.com/2024-02-08/guides/code-examples/model-sync-reverse-etl-from-snowflake-query-to-salesforce)
        - [Joined model sync from Postgres, Airtable, and Stripe to Hubspot](https://apidocs.polytomic.com/2024-02-08/guides/code-examples/joined-model-sync-from-postgres-airtable-and-stripe-to-hubspot)

        ## Targets (Destinations)

        Polytomic refers to a model sync's destination as the "target object", or
        target. Target objects are identified by a connection ID and an object ID. You
        can retrieve a list of all target objects for a connection using the [Get Target
        Objects](./targets/list) endpoint.

        The `target` object in the request specifies information about the sync destination.

        ```json
        "target": {
            "connection_id": "248df4b7-aa70-47b8-a036-33ac447e668d",
            "object": "Users",
        },
        ```

        Some connections support additional configuration for targets. For example,
        [Salesforce
        connections](https://apidocs.polytomic.com/2024-02-08/guides/configuring-your-connections/connections/salesforce#target)
        support optionally specifying the ingestion API to use. The target specific
        options are passed as `configuration`; consult the [integration
        guides](https://apidocs.polytomic.com/2024-02-08/guides/configuring-your-connections/overview)
        for details about specific connection configurations.

        ### Creating a new target

        Some integrations support creating a new target when creating a model sync. For
        example, an ad audience or database table.

        When creating a new target, `object` is omitted and `create` is specified
        instead. The `create` property is an object containing integration specific
        configuration for the new target.

        ```json
        "target": {
            "connection_id": "248df4b7-aa70-47b8-a036-33ac447e668d",
            "create": {
                "name": "New audience",
                "type": "user_audience"
            }
        },
        ```

        The [Get Target List](./targets/list) endpoint returns information about whether
        a connection supports target creation.

        Parameters
        ----------
        fields : typing.Sequence[ModelSyncField]
            Fields to sync from source to destination.

        mode : ModelSyncMode

        name : str

        schedule : Schedule

        target : Target

        active : typing.Optional[bool]
            Whether the sync is enabled and scheduled.

        encryption_passphrase : typing.Optional[str]
            Passphrase for encrypting the sync data.

        filter_logic : typing.Optional[str]
            Logical expression to combine filters.

        filters : typing.Optional[typing.Sequence[Filter]]
            Filters to apply to the source data.

        identity : typing.Optional[Identity]

        only_enrich_updates : typing.Optional[bool]
            Whether to use enrichment models as a source of possible changes to sync. If true, only changes to the base models will cause a record to sync.

        organization_id : typing.Optional[str]
            Organization ID for the sync; read-only with a partner key.

        override_fields : typing.Optional[typing.Sequence[ModelSyncField]]
            Values to set in the target unconditionally.

        overrides : typing.Optional[typing.Sequence[Override]]
            Conditional value replacement for fields.

        policies : typing.Optional[typing.Sequence[str]]

        skip_initial_backfill : typing.Optional[bool]
            Whether to skip the initial backfill of records; if true only records seen after the sync is enabled will be synced.

        sync_all_records : typing.Optional[bool]
            Whether to sync all records from the source, regardless of whether they've changed since the previous execution.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelSyncResponseEnvelope
            OK

        Examples
        --------
        from polytomic import ModelSyncField, Polytomic, Schedule, Target

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.create(
            fields=[
                ModelSyncField(
                    target="name",
                )
            ],
            mode="create",
            name="Users Sync",
            schedule=Schedule(),
            target=Target(
                connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/syncs",
            method="POST",
            json={
                "active": active,
                "encryption_passphrase": encryption_passphrase,
                "fields": convert_and_respect_annotation_metadata(
                    object_=fields, annotation=typing.Sequence[ModelSyncField], direction="write"
                ),
                "filter_logic": filter_logic,
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=typing.Sequence[Filter], direction="write"
                ),
                "identity": convert_and_respect_annotation_metadata(
                    object_=identity, annotation=Identity, direction="write"
                ),
                "mode": mode,
                "name": name,
                "only_enrich_updates": only_enrich_updates,
                "organization_id": organization_id,
                "override_fields": convert_and_respect_annotation_metadata(
                    object_=override_fields, annotation=typing.Sequence[ModelSyncField], direction="write"
                ),
                "overrides": convert_and_respect_annotation_metadata(
                    object_=overrides, annotation=typing.Sequence[Override], direction="write"
                ),
                "policies": policies,
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=Schedule, direction="write"
                ),
                "skip_initial_backfill": skip_initial_backfill,
                "sync_all_records": sync_all_records,
                "target": convert_and_respect_annotation_metadata(object_=target, annotation=Target, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=ModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def get_schedule_options(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ScheduleOptionResponseEnvelope:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ScheduleOptionResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.get_schedule_options()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/syncs/schedules",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ScheduleOptionResponseEnvelope,
                    parse_obj_as(
                        type_=ScheduleOptionResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> ModelSyncResponseEnvelope:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelSyncResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.get(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=ModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        id: str,
        *,
        fields: typing.Sequence[ModelSyncField],
        mode: ModelSyncMode,
        name: str,
        schedule: Schedule,
        target: Target,
        active: typing.Optional[bool] = OMIT,
        encryption_passphrase: typing.Optional[str] = OMIT,
        filter_logic: typing.Optional[str] = OMIT,
        filters: typing.Optional[typing.Sequence[Filter]] = OMIT,
        identity: typing.Optional[Identity] = OMIT,
        only_enrich_updates: typing.Optional[bool] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        override_fields: typing.Optional[typing.Sequence[ModelSyncField]] = OMIT,
        overrides: typing.Optional[typing.Sequence[Override]] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        skip_initial_backfill: typing.Optional[bool] = OMIT,
        sync_all_records: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelSyncResponseEnvelope:
        """
        Parameters
        ----------
        id : str

        fields : typing.Sequence[ModelSyncField]
            Fields to sync from source to destination.

        mode : ModelSyncMode

        name : str

        schedule : Schedule

        target : Target

        active : typing.Optional[bool]
            Whether the sync is enabled and scheduled.

        encryption_passphrase : typing.Optional[str]
            Passphrase for encrypting the sync data.

        filter_logic : typing.Optional[str]
            Logical expression to combine filters.

        filters : typing.Optional[typing.Sequence[Filter]]
            Filters to apply to the source data.

        identity : typing.Optional[Identity]

        only_enrich_updates : typing.Optional[bool]
            Whether to use enrichment models as a source of possible changes to sync. If true, only changes to the base models will cause a record to sync.

        organization_id : typing.Optional[str]
            Organization ID for the sync; read-only with a partner key.

        override_fields : typing.Optional[typing.Sequence[ModelSyncField]]
            Values to set in the target unconditionally.

        overrides : typing.Optional[typing.Sequence[Override]]
            Conditional value replacement for fields.

        policies : typing.Optional[typing.Sequence[str]]

        skip_initial_backfill : typing.Optional[bool]
            Whether to skip the initial backfill of records; if true only records seen after the sync is enabled will be synced.

        sync_all_records : typing.Optional[bool]
            Whether to sync all records from the source, regardless of whether they've changed since the previous execution.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelSyncResponseEnvelope
            OK

        Examples
        --------
        from polytomic import ModelSyncField, Polytomic, Schedule, Target

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.update(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
            fields=[
                ModelSyncField(
                    target="name",
                )
            ],
            mode="create",
            name="Users Sync",
            schedule=Schedule(),
            target=Target(
                connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "active": active,
                "encryption_passphrase": encryption_passphrase,
                "fields": convert_and_respect_annotation_metadata(
                    object_=fields, annotation=typing.Sequence[ModelSyncField], direction="write"
                ),
                "filter_logic": filter_logic,
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=typing.Sequence[Filter], direction="write"
                ),
                "identity": convert_and_respect_annotation_metadata(
                    object_=identity, annotation=Identity, direction="write"
                ),
                "mode": mode,
                "name": name,
                "only_enrich_updates": only_enrich_updates,
                "organization_id": organization_id,
                "override_fields": convert_and_respect_annotation_metadata(
                    object_=override_fields, annotation=typing.Sequence[ModelSyncField], direction="write"
                ),
                "overrides": convert_and_respect_annotation_metadata(
                    object_=overrides, annotation=typing.Sequence[Override], direction="write"
                ),
                "policies": policies,
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=Schedule, direction="write"
                ),
                "skip_initial_backfill": skip_initial_backfill,
                "sync_all_records": sync_all_records,
                "target": convert_and_respect_annotation_metadata(object_=target, annotation=Target, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=ModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def remove(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.remove(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def activate(
        self, id: str, *, active: bool, request_options: typing.Optional[RequestOptions] = None
    ) -> ActivateSyncEnvelope:
        """
        Parameters
        ----------
        id : str

        active : bool

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActivateSyncEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.activate(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
            active=True,
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}/activate",
            method="POST",
            json={
                "active": active,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ActivateSyncEnvelope,
                    parse_obj_as(
                        type_=ActivateSyncEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def cancel(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CancelModelSyncResponseEnvelope:
        """
        Parameters
        ----------
        id : str
            The active execution of this sync ID will be cancelled.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CancelModelSyncResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.cancel(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CancelModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=CancelModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def start(
        self,
        id: str,
        *,
        identities: typing.Optional[typing.Sequence[str]] = OMIT,
        resync: typing.Optional[bool] = OMIT,
        test: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> StartModelSyncResponseEnvelope:
        """
        > ðŸš§ Force full resync
        >
        > Use caution when setting the `resync` parameter to `true`. This will force a full resync of the data from the source system. This can be a time-consuming operation and may impact the performance of the source system. It is recommended to only use this option when necessary.

        Parameters
        ----------
        id : str

        identities : typing.Optional[typing.Sequence[str]]

        resync : typing.Optional[bool]

        test : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        StartModelSyncResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.start(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}/executions",
            method="POST",
            json={
                "identities": identities,
                "resync": resync,
                "test": test,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    StartModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=StartModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def get_status(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> SyncStatusEnvelope:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncStatusEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.model_sync.get_status(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SyncStatusEnvelope,
                    parse_obj_as(
                        type_=SyncStatusEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)


class AsyncModelSyncClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper
        self.targets = AsyncTargetsClient(client_wrapper=self._client_wrapper)
        self.executions = AsyncExecutionsClient(client_wrapper=self._client_wrapper)

    async def get_source(
        self,
        id: str,
        *,
        params: typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetModelSyncSourceMetaEnvelope:
        """
        Parameters
        ----------
        id : str

        params : typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetModelSyncSourceMetaEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.get_source(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/connections/{jsonable_encoder(id)}/modelsync/source",
            method="GET",
            params={
                "params": params,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetModelSyncSourceMetaEnvelope,
                    parse_obj_as(
                        type_=GetModelSyncSourceMetaEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def get_source_fields(
        self,
        id: str,
        *,
        params: typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelFieldResponse:
        """
        Parameters
        ----------
        id : str

        params : typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelFieldResponse
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.get_source_fields(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/connections/{jsonable_encoder(id)}/modelsync/source/fields",
            method="GET",
            params={
                "params": params,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelFieldResponse,
                    parse_obj_as(
                        type_=ModelFieldResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def list(
        self,
        *,
        active: typing.Optional[bool] = None,
        mode: typing.Optional[ModelSyncMode] = None,
        target_connection_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListModelSyncResponseEnvelope:
        """
        Parameters
        ----------
        active : typing.Optional[bool]

        mode : typing.Optional[ModelSyncMode]

        target_connection_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListModelSyncResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.list(
                active=True,
                target_connection_id="0b155265-c537-44c9-9359-a3ceb468a4da",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/syncs",
            method="GET",
            params={
                "active": active,
                "mode": mode,
                "target_connection_id": target_connection_id,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=ListModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        fields: typing.Sequence[ModelSyncField],
        mode: ModelSyncMode,
        name: str,
        schedule: Schedule,
        target: Target,
        active: typing.Optional[bool] = OMIT,
        encryption_passphrase: typing.Optional[str] = OMIT,
        filter_logic: typing.Optional[str] = OMIT,
        filters: typing.Optional[typing.Sequence[Filter]] = OMIT,
        identity: typing.Optional[Identity] = OMIT,
        only_enrich_updates: typing.Optional[bool] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        override_fields: typing.Optional[typing.Sequence[ModelSyncField]] = OMIT,
        overrides: typing.Optional[typing.Sequence[Override]] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        skip_initial_backfill: typing.Optional[bool] = OMIT,
        sync_all_records: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelSyncResponseEnvelope:
        """
        Create a new sync from one or more models to a destination.

        All of the functionality described in [the product
        documentation](https://docs.polytomic.com/docs/sync-destinations) is
        configurable via the API.

        Guides:

        - [Model sync (Reverse ETL) from Snowflake query to Salesforce](https://apidocs.polytomic.com/2024-02-08/guides/code-examples/model-sync-reverse-etl-from-snowflake-query-to-salesforce)
        - [Joined model sync from Postgres, Airtable, and Stripe to Hubspot](https://apidocs.polytomic.com/2024-02-08/guides/code-examples/joined-model-sync-from-postgres-airtable-and-stripe-to-hubspot)

        ## Targets (Destinations)

        Polytomic refers to a model sync's destination as the "target object", or
        target. Target objects are identified by a connection ID and an object ID. You
        can retrieve a list of all target objects for a connection using the [Get Target
        Objects](./targets/list) endpoint.

        The `target` object in the request specifies information about the sync destination.

        ```json
        "target": {
            "connection_id": "248df4b7-aa70-47b8-a036-33ac447e668d",
            "object": "Users",
        },
        ```

        Some connections support additional configuration for targets. For example,
        [Salesforce
        connections](https://apidocs.polytomic.com/2024-02-08/guides/configuring-your-connections/connections/salesforce#target)
        support optionally specifying the ingestion API to use. The target specific
        options are passed as `configuration`; consult the [integration
        guides](https://apidocs.polytomic.com/2024-02-08/guides/configuring-your-connections/overview)
        for details about specific connection configurations.

        ### Creating a new target

        Some integrations support creating a new target when creating a model sync. For
        example, an ad audience or database table.

        When creating a new target, `object` is omitted and `create` is specified
        instead. The `create` property is an object containing integration specific
        configuration for the new target.

        ```json
        "target": {
            "connection_id": "248df4b7-aa70-47b8-a036-33ac447e668d",
            "create": {
                "name": "New audience",
                "type": "user_audience"
            }
        },
        ```

        The [Get Target List](./targets/list) endpoint returns information about whether
        a connection supports target creation.

        Parameters
        ----------
        fields : typing.Sequence[ModelSyncField]
            Fields to sync from source to destination.

        mode : ModelSyncMode

        name : str

        schedule : Schedule

        target : Target

        active : typing.Optional[bool]
            Whether the sync is enabled and scheduled.

        encryption_passphrase : typing.Optional[str]
            Passphrase for encrypting the sync data.

        filter_logic : typing.Optional[str]
            Logical expression to combine filters.

        filters : typing.Optional[typing.Sequence[Filter]]
            Filters to apply to the source data.

        identity : typing.Optional[Identity]

        only_enrich_updates : typing.Optional[bool]
            Whether to use enrichment models as a source of possible changes to sync. If true, only changes to the base models will cause a record to sync.

        organization_id : typing.Optional[str]
            Organization ID for the sync; read-only with a partner key.

        override_fields : typing.Optional[typing.Sequence[ModelSyncField]]
            Values to set in the target unconditionally.

        overrides : typing.Optional[typing.Sequence[Override]]
            Conditional value replacement for fields.

        policies : typing.Optional[typing.Sequence[str]]

        skip_initial_backfill : typing.Optional[bool]
            Whether to skip the initial backfill of records; if true only records seen after the sync is enabled will be synced.

        sync_all_records : typing.Optional[bool]
            Whether to sync all records from the source, regardless of whether they've changed since the previous execution.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelSyncResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic, ModelSyncField, Schedule, Target

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.create(
                fields=[
                    ModelSyncField(
                        target="name",
                    )
                ],
                mode="create",
                name="Users Sync",
                schedule=Schedule(),
                target=Target(
                    connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/syncs",
            method="POST",
            json={
                "active": active,
                "encryption_passphrase": encryption_passphrase,
                "fields": convert_and_respect_annotation_metadata(
                    object_=fields, annotation=typing.Sequence[ModelSyncField], direction="write"
                ),
                "filter_logic": filter_logic,
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=typing.Sequence[Filter], direction="write"
                ),
                "identity": convert_and_respect_annotation_metadata(
                    object_=identity, annotation=Identity, direction="write"
                ),
                "mode": mode,
                "name": name,
                "only_enrich_updates": only_enrich_updates,
                "organization_id": organization_id,
                "override_fields": convert_and_respect_annotation_metadata(
                    object_=override_fields, annotation=typing.Sequence[ModelSyncField], direction="write"
                ),
                "overrides": convert_and_respect_annotation_metadata(
                    object_=overrides, annotation=typing.Sequence[Override], direction="write"
                ),
                "policies": policies,
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=Schedule, direction="write"
                ),
                "skip_initial_backfill": skip_initial_backfill,
                "sync_all_records": sync_all_records,
                "target": convert_and_respect_annotation_metadata(object_=target, annotation=Target, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=ModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def get_schedule_options(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ScheduleOptionResponseEnvelope:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ScheduleOptionResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.get_schedule_options()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/syncs/schedules",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ScheduleOptionResponseEnvelope,
                    parse_obj_as(
                        type_=ScheduleOptionResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ModelSyncResponseEnvelope:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelSyncResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.get(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=ModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        id: str,
        *,
        fields: typing.Sequence[ModelSyncField],
        mode: ModelSyncMode,
        name: str,
        schedule: Schedule,
        target: Target,
        active: typing.Optional[bool] = OMIT,
        encryption_passphrase: typing.Optional[str] = OMIT,
        filter_logic: typing.Optional[str] = OMIT,
        filters: typing.Optional[typing.Sequence[Filter]] = OMIT,
        identity: typing.Optional[Identity] = OMIT,
        only_enrich_updates: typing.Optional[bool] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        override_fields: typing.Optional[typing.Sequence[ModelSyncField]] = OMIT,
        overrides: typing.Optional[typing.Sequence[Override]] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        skip_initial_backfill: typing.Optional[bool] = OMIT,
        sync_all_records: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelSyncResponseEnvelope:
        """
        Parameters
        ----------
        id : str

        fields : typing.Sequence[ModelSyncField]
            Fields to sync from source to destination.

        mode : ModelSyncMode

        name : str

        schedule : Schedule

        target : Target

        active : typing.Optional[bool]
            Whether the sync is enabled and scheduled.

        encryption_passphrase : typing.Optional[str]
            Passphrase for encrypting the sync data.

        filter_logic : typing.Optional[str]
            Logical expression to combine filters.

        filters : typing.Optional[typing.Sequence[Filter]]
            Filters to apply to the source data.

        identity : typing.Optional[Identity]

        only_enrich_updates : typing.Optional[bool]
            Whether to use enrichment models as a source of possible changes to sync. If true, only changes to the base models will cause a record to sync.

        organization_id : typing.Optional[str]
            Organization ID for the sync; read-only with a partner key.

        override_fields : typing.Optional[typing.Sequence[ModelSyncField]]
            Values to set in the target unconditionally.

        overrides : typing.Optional[typing.Sequence[Override]]
            Conditional value replacement for fields.

        policies : typing.Optional[typing.Sequence[str]]

        skip_initial_backfill : typing.Optional[bool]
            Whether to skip the initial backfill of records; if true only records seen after the sync is enabled will be synced.

        sync_all_records : typing.Optional[bool]
            Whether to sync all records from the source, regardless of whether they've changed since the previous execution.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelSyncResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic, ModelSyncField, Schedule, Target

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.update(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
                fields=[
                    ModelSyncField(
                        target="name",
                    )
                ],
                mode="create",
                name="Users Sync",
                schedule=Schedule(),
                target=Target(
                    connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}",
            method="PUT",
            json={
                "active": active,
                "encryption_passphrase": encryption_passphrase,
                "fields": convert_and_respect_annotation_metadata(
                    object_=fields, annotation=typing.Sequence[ModelSyncField], direction="write"
                ),
                "filter_logic": filter_logic,
                "filters": convert_and_respect_annotation_metadata(
                    object_=filters, annotation=typing.Sequence[Filter], direction="write"
                ),
                "identity": convert_and_respect_annotation_metadata(
                    object_=identity, annotation=Identity, direction="write"
                ),
                "mode": mode,
                "name": name,
                "only_enrich_updates": only_enrich_updates,
                "organization_id": organization_id,
                "override_fields": convert_and_respect_annotation_metadata(
                    object_=override_fields, annotation=typing.Sequence[ModelSyncField], direction="write"
                ),
                "overrides": convert_and_respect_annotation_metadata(
                    object_=overrides, annotation=typing.Sequence[Override], direction="write"
                ),
                "policies": policies,
                "schedule": convert_and_respect_annotation_metadata(
                    object_=schedule, annotation=Schedule, direction="write"
                ),
                "skip_initial_backfill": skip_initial_backfill,
                "sync_all_records": sync_all_records,
                "target": convert_and_respect_annotation_metadata(object_=target, annotation=Target, direction="write"),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=ModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def remove(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.remove(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}",
            method="DELETE",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def activate(
        self, id: str, *, active: bool, request_options: typing.Optional[RequestOptions] = None
    ) -> ActivateSyncEnvelope:
        """
        Parameters
        ----------
        id : str

        active : bool

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ActivateSyncEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.activate(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
                active=True,
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}/activate",
            method="POST",
            json={
                "active": active,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ActivateSyncEnvelope,
                    parse_obj_as(
                        type_=ActivateSyncEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def cancel(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> CancelModelSyncResponseEnvelope:
        """
        Parameters
        ----------
        id : str
            The active execution of this sync ID will be cancelled.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CancelModelSyncResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.cancel(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}/cancel",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    CancelModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=CancelModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def start(
        self,
        id: str,
        *,
        identities: typing.Optional[typing.Sequence[str]] = OMIT,
        resync: typing.Optional[bool] = OMIT,
        test: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> StartModelSyncResponseEnvelope:
        """
        > ðŸš§ Force full resync
        >
        > Use caution when setting the `resync` parameter to `true`. This will force a full resync of the data from the source system. This can be a time-consuming operation and may impact the performance of the source system. It is recommended to only use this option when necessary.

        Parameters
        ----------
        id : str

        identities : typing.Optional[typing.Sequence[str]]

        resync : typing.Optional[bool]

        test : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        StartModelSyncResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.start(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}/executions",
            method="POST",
            json={
                "identities": identities,
                "resync": resync,
                "test": test,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    StartModelSyncResponseEnvelope,
                    parse_obj_as(
                        type_=StartModelSyncResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def get_status(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SyncStatusEnvelope:
        """
        Parameters
        ----------
        id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncStatusEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.model_sync.get_status(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/syncs/{jsonable_encoder(id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SyncStatusEnvelope,
                    parse_obj_as(
                        type_=SyncStatusEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)
