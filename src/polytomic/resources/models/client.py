# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...errors.unauthorized_error import UnauthorizedError
from ...types.rest_err_response import RestErrResponse
from ...types.v_2_model_field_request import V2ModelFieldRequest
from ...types.v_2_model_list_response_envelope import V2ModelListResponseEnvelope
from ...types.v_2_model_response_envelope import V2ModelResponseEnvelope
from ...types.v_2_relation import V2Relation

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ModelsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(self) -> V2ModelListResponseEnvelope:
        """
        from polytomic.client import Polytomic

        client = Polytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/models"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(V2ModelListResponseEnvelope, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        additional_fields: typing.Optional[typing.List[V2ModelFieldRequest]] = OMIT,
        configuration: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        connection_id: str,
        fields: typing.Optional[typing.List[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.List[str]] = OMIT,
        name: str,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.List[str]] = OMIT,
        relations: typing.Optional[typing.List[V2Relation]] = OMIT,
        tracking_columns: typing.Optional[typing.List[str]] = OMIT,
    ) -> V2ModelResponseEnvelope:
        """
        Parameters:
            - additional_fields: typing.Optional[typing.List[V2ModelFieldRequest]].

            - configuration: typing.Optional[typing.Dict[str, typing.Any]].

            - connection_id: str.

            - fields: typing.Optional[typing.List[str]].

            - identifier: typing.Optional[str].

            - labels: typing.Optional[typing.List[str]].

            - name: str.

            - organization_id: typing.Optional[str].

            - policies: typing.Optional[typing.List[str]].

            - relations: typing.Optional[typing.List[V2Relation]].

            - tracking_columns: typing.Optional[typing.List[str]].
        ---
        from polytomic.client import Polytomic

        client = Polytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.create(
            connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            name="name",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"connection_id": connection_id, "name": name}
        if additional_fields is not OMIT:
            _request["additional_fields"] = additional_fields
        if configuration is not OMIT:
            _request["configuration"] = configuration
        if fields is not OMIT:
            _request["fields"] = fields
        if identifier is not OMIT:
            _request["identifier"] = identifier
        if labels is not OMIT:
            _request["labels"] = labels
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        if policies is not OMIT:
            _request["policies"] = policies
        if relations is not OMIT:
            _request["relations"] = relations
        if tracking_columns is not OMIT:
            _request["tracking_columns"] = tracking_columns
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/models"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(V2ModelResponseEnvelope, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, id: str) -> V2ModelResponseEnvelope:
        """
        Parameters:
            - id: str.
        ---
        from polytomic.client import Polytomic

        client = Polytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.get(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/models/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(V2ModelResponseEnvelope, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def remove(self, id: str) -> None:
        """
        Parameters:
            - id: str.
        ---
        from polytomic.client import Polytomic

        client = Polytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.remove(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/models/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        id: str,
        *,
        additional_fields: typing.Optional[typing.List[V2ModelFieldRequest]] = OMIT,
        configuration: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        connection_id: str,
        fields: typing.Optional[typing.List[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.List[str]] = OMIT,
        name: str,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.List[str]] = OMIT,
        relations: typing.Optional[typing.List[V2Relation]] = OMIT,
        tracking_columns: typing.Optional[typing.List[str]] = OMIT,
    ) -> V2ModelResponseEnvelope:
        """
        Parameters:
            - id: str.

            - additional_fields: typing.Optional[typing.List[V2ModelFieldRequest]].

            - configuration: typing.Optional[typing.Dict[str, typing.Any]].

            - connection_id: str.

            - fields: typing.Optional[typing.List[str]].

            - identifier: typing.Optional[str].

            - labels: typing.Optional[typing.List[str]].

            - name: str.

            - organization_id: typing.Optional[str].

            - policies: typing.Optional[typing.List[str]].

            - relations: typing.Optional[typing.List[V2Relation]].

            - tracking_columns: typing.Optional[typing.List[str]].
        ---
        from polytomic.client import Polytomic

        client = Polytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.update(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
            connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            name="name",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"connection_id": connection_id, "name": name}
        if additional_fields is not OMIT:
            _request["additional_fields"] = additional_fields
        if configuration is not OMIT:
            _request["configuration"] = configuration
        if fields is not OMIT:
            _request["fields"] = fields
        if identifier is not OMIT:
            _request["identifier"] = identifier
        if labels is not OMIT:
            _request["labels"] = labels
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        if policies is not OMIT:
            _request["policies"] = policies
        if relations is not OMIT:
            _request["relations"] = relations
        if tracking_columns is not OMIT:
            _request["tracking_columns"] = tracking_columns
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/models/{id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(V2ModelResponseEnvelope, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncModelsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(self) -> V2ModelListResponseEnvelope:
        """
        from polytomic.client import AsyncPolytomic

        client = AsyncPolytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        await client.models.list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/models"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(V2ModelListResponseEnvelope, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        additional_fields: typing.Optional[typing.List[V2ModelFieldRequest]] = OMIT,
        configuration: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        connection_id: str,
        fields: typing.Optional[typing.List[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.List[str]] = OMIT,
        name: str,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.List[str]] = OMIT,
        relations: typing.Optional[typing.List[V2Relation]] = OMIT,
        tracking_columns: typing.Optional[typing.List[str]] = OMIT,
    ) -> V2ModelResponseEnvelope:
        """
        Parameters:
            - additional_fields: typing.Optional[typing.List[V2ModelFieldRequest]].

            - configuration: typing.Optional[typing.Dict[str, typing.Any]].

            - connection_id: str.

            - fields: typing.Optional[typing.List[str]].

            - identifier: typing.Optional[str].

            - labels: typing.Optional[typing.List[str]].

            - name: str.

            - organization_id: typing.Optional[str].

            - policies: typing.Optional[typing.List[str]].

            - relations: typing.Optional[typing.List[V2Relation]].

            - tracking_columns: typing.Optional[typing.List[str]].
        ---
        from polytomic.client import AsyncPolytomic

        client = AsyncPolytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        await client.models.create(
            connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            name="name",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"connection_id": connection_id, "name": name}
        if additional_fields is not OMIT:
            _request["additional_fields"] = additional_fields
        if configuration is not OMIT:
            _request["configuration"] = configuration
        if fields is not OMIT:
            _request["fields"] = fields
        if identifier is not OMIT:
            _request["identifier"] = identifier
        if labels is not OMIT:
            _request["labels"] = labels
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        if policies is not OMIT:
            _request["policies"] = policies
        if relations is not OMIT:
            _request["relations"] = relations
        if tracking_columns is not OMIT:
            _request["tracking_columns"] = tracking_columns
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/models"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(V2ModelResponseEnvelope, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, id: str) -> V2ModelResponseEnvelope:
        """
        Parameters:
            - id: str.
        ---
        from polytomic.client import AsyncPolytomic

        client = AsyncPolytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        await client.models.get(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/models/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(V2ModelResponseEnvelope, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def remove(self, id: str) -> None:
        """
        Parameters:
            - id: str.
        ---
        from polytomic.client import AsyncPolytomic

        client = AsyncPolytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        await client.models.remove(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/models/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        id: str,
        *,
        additional_fields: typing.Optional[typing.List[V2ModelFieldRequest]] = OMIT,
        configuration: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        connection_id: str,
        fields: typing.Optional[typing.List[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.List[str]] = OMIT,
        name: str,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.List[str]] = OMIT,
        relations: typing.Optional[typing.List[V2Relation]] = OMIT,
        tracking_columns: typing.Optional[typing.List[str]] = OMIT,
    ) -> V2ModelResponseEnvelope:
        """
        Parameters:
            - id: str.

            - additional_fields: typing.Optional[typing.List[V2ModelFieldRequest]].

            - configuration: typing.Optional[typing.Dict[str, typing.Any]].

            - connection_id: str.

            - fields: typing.Optional[typing.List[str]].

            - identifier: typing.Optional[str].

            - labels: typing.Optional[typing.List[str]].

            - name: str.

            - organization_id: typing.Optional[str].

            - policies: typing.Optional[typing.List[str]].

            - relations: typing.Optional[typing.List[V2Relation]].

            - tracking_columns: typing.Optional[typing.List[str]].
        ---
        from polytomic.client import AsyncPolytomic

        client = AsyncPolytomic(
            polytomic_version="YOUR_POLYTOMIC_VERSION",
            token="YOUR_TOKEN",
        )
        await client.models.update(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
            connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            name="name",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"connection_id": connection_id, "name": name}
        if additional_fields is not OMIT:
            _request["additional_fields"] = additional_fields
        if configuration is not OMIT:
            _request["configuration"] = configuration
        if fields is not OMIT:
            _request["fields"] = fields
        if identifier is not OMIT:
            _request["identifier"] = identifier
        if labels is not OMIT:
            _request["labels"] = labels
        if organization_id is not OMIT:
            _request["organization_id"] = organization_id
        if policies is not OMIT:
            _request["policies"] = policies
        if relations is not OMIT:
            _request["relations"] = relations
        if tracking_columns is not OMIT:
            _request["tracking_columns"] = tracking_columns
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/models/{id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(V2ModelResponseEnvelope, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(RestErrResponse, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
