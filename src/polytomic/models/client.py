# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.get_model_sync_source_meta_envelope import GetModelSyncSourceMetaEnvelope
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from ..types.api_error import ApiError as types_api_error_ApiError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.rest_err_response import RestErrResponse
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_found_error import NotFoundError
from ..errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError as core_api_error_ApiError
from ..types.v_2_enricher_configuration import V2EnricherConfiguration
from ..types.v_2_get_enrichment_input_fields_response_envelope import V2GetEnrichmentInputFieldsResponseEnvelope
from ..types.model_model_field_request import ModelModelFieldRequest
from ..types.enrichment import Enrichment
from ..types.model_relation import ModelRelation
from ..types.model_response_envelope import ModelResponseEnvelope
from ..core.serialization import convert_and_respect_annotation_metadata
from ..types.model_list_response_envelope import ModelListResponseEnvelope
from ..types.model_sample_response_envelope import ModelSampleResponseEnvelope
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ModelsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_enrichment_source(
        self,
        id: str,
        *,
        params: typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetModelSyncSourceMetaEnvelope:
        """
        Parameters
        ----------
        id : str

        params : typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetModelSyncSourceMetaEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.get_enrichment_source(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/connections/{jsonable_encoder(id)}/modelsync/enrichment-source",
            method="GET",
            params={
                "params": params,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetModelSyncSourceMetaEnvelope,
                    parse_obj_as(
                        type_=GetModelSyncSourceMetaEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def post(
        self,
        connection_id: str,
        *,
        configuration: typing.Optional[V2EnricherConfiguration] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> V2GetEnrichmentInputFieldsResponseEnvelope:
        """
        For a given connection and enrichment configuration, provides the valid sets of input fields.

        Parameters
        ----------
        connection_id : str

        configuration : typing.Optional[V2EnricherConfiguration]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        V2GetEnrichmentInputFieldsResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.post(
            connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/enrichment/{jsonable_encoder(connection_id)}/inputfields",
            method="POST",
            json={
                "configuration": configuration,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    V2GetEnrichmentInputFieldsResponseEnvelope,
                    parse_obj_as(
                        type_=V2GetEnrichmentInputFieldsResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def preview(
        self,
        *,
        configuration: typing.Dict[str, typing.Optional[typing.Any]],
        connection_id: str,
        name: str,
        async_: typing.Optional[bool] = None,
        additional_fields: typing.Optional[typing.Sequence[ModelModelFieldRequest]] = OMIT,
        enricher: typing.Optional[Enrichment] = OMIT,
        fields: typing.Optional[typing.Sequence[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        relations: typing.Optional[typing.Sequence[ModelRelation]] = OMIT,
        tracking_columns: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelResponseEnvelope:
        """
        Parameters
        ----------
        configuration : typing.Dict[str, typing.Optional[typing.Any]]

        connection_id : str

        name : str

        async_ : typing.Optional[bool]

        additional_fields : typing.Optional[typing.Sequence[ModelModelFieldRequest]]

        enricher : typing.Optional[Enrichment]

        fields : typing.Optional[typing.Sequence[str]]

        identifier : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        organization_id : typing.Optional[str]

        policies : typing.Optional[typing.Sequence[str]]

        relations : typing.Optional[typing.Sequence[ModelRelation]]

        tracking_columns : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.preview(
            configuration={"table": "public.users"},
            connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            name="Users",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/model-preview",
            method="POST",
            params={
                "async": async_,
            },
            json={
                "additional_fields": convert_and_respect_annotation_metadata(
                    object_=additional_fields, annotation=typing.Sequence[ModelModelFieldRequest], direction="write"
                ),
                "configuration": configuration,
                "connection_id": connection_id,
                "enricher": convert_and_respect_annotation_metadata(
                    object_=enricher, annotation=Enrichment, direction="write"
                ),
                "fields": fields,
                "identifier": identifier,
                "labels": labels,
                "name": name,
                "organization_id": organization_id,
                "policies": policies,
                "relations": convert_and_respect_annotation_metadata(
                    object_=relations, annotation=typing.Sequence[ModelRelation], direction="write"
                ),
                "tracking_columns": tracking_columns,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelResponseEnvelope,
                    parse_obj_as(
                        type_=ModelResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> ModelListResponseEnvelope:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelListResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/models",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelListResponseEnvelope,
                    parse_obj_as(
                        type_=ModelListResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        configuration: typing.Dict[str, typing.Optional[typing.Any]],
        connection_id: str,
        name: str,
        async_: typing.Optional[bool] = None,
        additional_fields: typing.Optional[typing.Sequence[ModelModelFieldRequest]] = OMIT,
        enricher: typing.Optional[Enrichment] = OMIT,
        fields: typing.Optional[typing.Sequence[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        relations: typing.Optional[typing.Sequence[ModelRelation]] = OMIT,
        tracking_columns: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelResponseEnvelope:
        """
        Parameters
        ----------
        configuration : typing.Dict[str, typing.Optional[typing.Any]]

        connection_id : str

        name : str

        async_ : typing.Optional[bool]

        additional_fields : typing.Optional[typing.Sequence[ModelModelFieldRequest]]

        enricher : typing.Optional[Enrichment]

        fields : typing.Optional[typing.Sequence[str]]

        identifier : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        organization_id : typing.Optional[str]

        policies : typing.Optional[typing.Sequence[str]]

        relations : typing.Optional[typing.Sequence[ModelRelation]]

        tracking_columns : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.create(
            configuration={"table": "public.users"},
            connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            name="Users",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/models",
            method="POST",
            params={
                "async": async_,
            },
            json={
                "additional_fields": convert_and_respect_annotation_metadata(
                    object_=additional_fields, annotation=typing.Sequence[ModelModelFieldRequest], direction="write"
                ),
                "configuration": configuration,
                "connection_id": connection_id,
                "enricher": convert_and_respect_annotation_metadata(
                    object_=enricher, annotation=Enrichment, direction="write"
                ),
                "fields": fields,
                "identifier": identifier,
                "labels": labels,
                "name": name,
                "organization_id": organization_id,
                "policies": policies,
                "relations": convert_and_respect_annotation_metadata(
                    object_=relations, annotation=typing.Sequence[ModelRelation], direction="write"
                ),
                "tracking_columns": tracking_columns,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelResponseEnvelope,
                    parse_obj_as(
                        type_=ModelResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def get(
        self, id: str, *, async_: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> ModelResponseEnvelope:
        """
        Parameters
        ----------
        id : str

        async_ : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.get(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/models/{jsonable_encoder(id)}",
            method="GET",
            params={
                "async": async_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelResponseEnvelope,
                    parse_obj_as(
                        type_=ModelResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        id: str,
        *,
        configuration: typing.Dict[str, typing.Optional[typing.Any]],
        connection_id: str,
        name: str,
        async_: typing.Optional[bool] = None,
        additional_fields: typing.Optional[typing.Sequence[ModelModelFieldRequest]] = OMIT,
        enricher: typing.Optional[Enrichment] = OMIT,
        fields: typing.Optional[typing.Sequence[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        refresh: typing.Optional[bool] = OMIT,
        relations: typing.Optional[typing.Sequence[ModelRelation]] = OMIT,
        tracking_columns: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelResponseEnvelope:
        """
        Parameters
        ----------
        id : str

        configuration : typing.Dict[str, typing.Optional[typing.Any]]

        connection_id : str

        name : str

        async_ : typing.Optional[bool]

        additional_fields : typing.Optional[typing.Sequence[ModelModelFieldRequest]]

        enricher : typing.Optional[Enrichment]

        fields : typing.Optional[typing.Sequence[str]]

        identifier : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        organization_id : typing.Optional[str]

        policies : typing.Optional[typing.Sequence[str]]

        refresh : typing.Optional[bool]

        relations : typing.Optional[typing.Sequence[ModelRelation]]

        tracking_columns : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.update(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
            async_=False,
            configuration={"table": "public.users"},
            connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            name="Users",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/models/{jsonable_encoder(id)}",
            method="PUT",
            params={
                "async": async_,
            },
            json={
                "additional_fields": convert_and_respect_annotation_metadata(
                    object_=additional_fields, annotation=typing.Sequence[ModelModelFieldRequest], direction="write"
                ),
                "configuration": configuration,
                "connection_id": connection_id,
                "enricher": convert_and_respect_annotation_metadata(
                    object_=enricher, annotation=Enrichment, direction="write"
                ),
                "fields": fields,
                "identifier": identifier,
                "labels": labels,
                "name": name,
                "organization_id": organization_id,
                "policies": policies,
                "refresh": refresh,
                "relations": convert_and_respect_annotation_metadata(
                    object_=relations, annotation=typing.Sequence[ModelRelation], direction="write"
                ),
                "tracking_columns": tracking_columns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelResponseEnvelope,
                    parse_obj_as(
                        type_=ModelResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def remove(
        self, id: str, *, async_: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        id : str

        async_ : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.remove(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/models/{jsonable_encoder(id)}",
            method="DELETE",
            params={
                "async": async_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    def sample(
        self, id: str, *, async_: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> ModelSampleResponseEnvelope:
        """
        Returns sample records from the model. The first ten records that the source provides will be returned after being enriched (if applicable). Synchronous requests must complete within 10s. If either querying or enrichment exceeds 10s, please use the async option.

        Parameters
        ----------
        id : str

        async_ : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelSampleResponseEnvelope
            OK

        Examples
        --------
        from polytomic import Polytomic

        client = Polytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )
        client.models.sample(
            id="248df4b7-aa70-47b8-a036-33ac447e668d",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/models/{jsonable_encoder(id)}/sample",
            method="GET",
            params={
                "async": async_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelSampleResponseEnvelope,
                    parse_obj_as(
                        type_=ModelSampleResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)


class AsyncModelsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_enrichment_source(
        self,
        id: str,
        *,
        params: typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetModelSyncSourceMetaEnvelope:
        """
        Parameters
        ----------
        id : str

        params : typing.Optional[typing.Dict[str, typing.Optional[typing.Sequence[str]]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetModelSyncSourceMetaEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.models.get_enrichment_source(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/connections/{jsonable_encoder(id)}/modelsync/enrichment-source",
            method="GET",
            params={
                "params": params,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetModelSyncSourceMetaEnvelope,
                    parse_obj_as(
                        type_=GetModelSyncSourceMetaEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def post(
        self,
        connection_id: str,
        *,
        configuration: typing.Optional[V2EnricherConfiguration] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> V2GetEnrichmentInputFieldsResponseEnvelope:
        """
        For a given connection and enrichment configuration, provides the valid sets of input fields.

        Parameters
        ----------
        connection_id : str

        configuration : typing.Optional[V2EnricherConfiguration]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        V2GetEnrichmentInputFieldsResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.models.post(
                connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/enrichment/{jsonable_encoder(connection_id)}/inputfields",
            method="POST",
            json={
                "configuration": configuration,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    V2GetEnrichmentInputFieldsResponseEnvelope,
                    parse_obj_as(
                        type_=V2GetEnrichmentInputFieldsResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def preview(
        self,
        *,
        configuration: typing.Dict[str, typing.Optional[typing.Any]],
        connection_id: str,
        name: str,
        async_: typing.Optional[bool] = None,
        additional_fields: typing.Optional[typing.Sequence[ModelModelFieldRequest]] = OMIT,
        enricher: typing.Optional[Enrichment] = OMIT,
        fields: typing.Optional[typing.Sequence[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        relations: typing.Optional[typing.Sequence[ModelRelation]] = OMIT,
        tracking_columns: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelResponseEnvelope:
        """
        Parameters
        ----------
        configuration : typing.Dict[str, typing.Optional[typing.Any]]

        connection_id : str

        name : str

        async_ : typing.Optional[bool]

        additional_fields : typing.Optional[typing.Sequence[ModelModelFieldRequest]]

        enricher : typing.Optional[Enrichment]

        fields : typing.Optional[typing.Sequence[str]]

        identifier : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        organization_id : typing.Optional[str]

        policies : typing.Optional[typing.Sequence[str]]

        relations : typing.Optional[typing.Sequence[ModelRelation]]

        tracking_columns : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.models.preview(
                configuration={"table": "public.users"},
                connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
                name="Users",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/model-preview",
            method="POST",
            params={
                "async": async_,
            },
            json={
                "additional_fields": convert_and_respect_annotation_metadata(
                    object_=additional_fields, annotation=typing.Sequence[ModelModelFieldRequest], direction="write"
                ),
                "configuration": configuration,
                "connection_id": connection_id,
                "enricher": convert_and_respect_annotation_metadata(
                    object_=enricher, annotation=Enrichment, direction="write"
                ),
                "fields": fields,
                "identifier": identifier,
                "labels": labels,
                "name": name,
                "organization_id": organization_id,
                "policies": policies,
                "relations": convert_and_respect_annotation_metadata(
                    object_=relations, annotation=typing.Sequence[ModelRelation], direction="write"
                ),
                "tracking_columns": tracking_columns,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelResponseEnvelope,
                    parse_obj_as(
                        type_=ModelResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def list(self, *, request_options: typing.Optional[RequestOptions] = None) -> ModelListResponseEnvelope:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelListResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.models.list()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/models",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelListResponseEnvelope,
                    parse_obj_as(
                        type_=ModelListResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        configuration: typing.Dict[str, typing.Optional[typing.Any]],
        connection_id: str,
        name: str,
        async_: typing.Optional[bool] = None,
        additional_fields: typing.Optional[typing.Sequence[ModelModelFieldRequest]] = OMIT,
        enricher: typing.Optional[Enrichment] = OMIT,
        fields: typing.Optional[typing.Sequence[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        relations: typing.Optional[typing.Sequence[ModelRelation]] = OMIT,
        tracking_columns: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelResponseEnvelope:
        """
        Parameters
        ----------
        configuration : typing.Dict[str, typing.Optional[typing.Any]]

        connection_id : str

        name : str

        async_ : typing.Optional[bool]

        additional_fields : typing.Optional[typing.Sequence[ModelModelFieldRequest]]

        enricher : typing.Optional[Enrichment]

        fields : typing.Optional[typing.Sequence[str]]

        identifier : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        organization_id : typing.Optional[str]

        policies : typing.Optional[typing.Sequence[str]]

        relations : typing.Optional[typing.Sequence[ModelRelation]]

        tracking_columns : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.models.create(
                configuration={"table": "public.users"},
                connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
                name="Users",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/models",
            method="POST",
            params={
                "async": async_,
            },
            json={
                "additional_fields": convert_and_respect_annotation_metadata(
                    object_=additional_fields, annotation=typing.Sequence[ModelModelFieldRequest], direction="write"
                ),
                "configuration": configuration,
                "connection_id": connection_id,
                "enricher": convert_and_respect_annotation_metadata(
                    object_=enricher, annotation=Enrichment, direction="write"
                ),
                "fields": fields,
                "identifier": identifier,
                "labels": labels,
                "name": name,
                "organization_id": organization_id,
                "policies": policies,
                "relations": convert_and_respect_annotation_metadata(
                    object_=relations, annotation=typing.Sequence[ModelRelation], direction="write"
                ),
                "tracking_columns": tracking_columns,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelResponseEnvelope,
                    parse_obj_as(
                        type_=ModelResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, id: str, *, async_: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> ModelResponseEnvelope:
        """
        Parameters
        ----------
        id : str

        async_ : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.models.get(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/models/{jsonable_encoder(id)}",
            method="GET",
            params={
                "async": async_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelResponseEnvelope,
                    parse_obj_as(
                        type_=ModelResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        id: str,
        *,
        configuration: typing.Dict[str, typing.Optional[typing.Any]],
        connection_id: str,
        name: str,
        async_: typing.Optional[bool] = None,
        additional_fields: typing.Optional[typing.Sequence[ModelModelFieldRequest]] = OMIT,
        enricher: typing.Optional[Enrichment] = OMIT,
        fields: typing.Optional[typing.Sequence[str]] = OMIT,
        identifier: typing.Optional[str] = OMIT,
        labels: typing.Optional[typing.Sequence[str]] = OMIT,
        organization_id: typing.Optional[str] = OMIT,
        policies: typing.Optional[typing.Sequence[str]] = OMIT,
        refresh: typing.Optional[bool] = OMIT,
        relations: typing.Optional[typing.Sequence[ModelRelation]] = OMIT,
        tracking_columns: typing.Optional[typing.Sequence[str]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ModelResponseEnvelope:
        """
        Parameters
        ----------
        id : str

        configuration : typing.Dict[str, typing.Optional[typing.Any]]

        connection_id : str

        name : str

        async_ : typing.Optional[bool]

        additional_fields : typing.Optional[typing.Sequence[ModelModelFieldRequest]]

        enricher : typing.Optional[Enrichment]

        fields : typing.Optional[typing.Sequence[str]]

        identifier : typing.Optional[str]

        labels : typing.Optional[typing.Sequence[str]]

        organization_id : typing.Optional[str]

        policies : typing.Optional[typing.Sequence[str]]

        refresh : typing.Optional[bool]

        relations : typing.Optional[typing.Sequence[ModelRelation]]

        tracking_columns : typing.Optional[typing.Sequence[str]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.models.update(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
                async_=False,
                configuration={"table": "public.users"},
                connection_id="248df4b7-aa70-47b8-a036-33ac447e668d",
                name="Users",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/models/{jsonable_encoder(id)}",
            method="PUT",
            params={
                "async": async_,
            },
            json={
                "additional_fields": convert_and_respect_annotation_metadata(
                    object_=additional_fields, annotation=typing.Sequence[ModelModelFieldRequest], direction="write"
                ),
                "configuration": configuration,
                "connection_id": connection_id,
                "enricher": convert_and_respect_annotation_metadata(
                    object_=enricher, annotation=Enrichment, direction="write"
                ),
                "fields": fields,
                "identifier": identifier,
                "labels": labels,
                "name": name,
                "organization_id": organization_id,
                "policies": policies,
                "refresh": refresh,
                "relations": convert_and_respect_annotation_metadata(
                    object_=relations, annotation=typing.Sequence[ModelRelation], direction="write"
                ),
                "tracking_columns": tracking_columns,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelResponseEnvelope,
                    parse_obj_as(
                        type_=ModelResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def remove(
        self, id: str, *, async_: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> None:
        """
        Parameters
        ----------
        id : str

        async_ : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.models.remove(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/models/{jsonable_encoder(id)}",
            method="DELETE",
            params={
                "async": async_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)

    async def sample(
        self, id: str, *, async_: typing.Optional[bool] = None, request_options: typing.Optional[RequestOptions] = None
    ) -> ModelSampleResponseEnvelope:
        """
        Returns sample records from the model. The first ten records that the source provides will be returned after being enriched (if applicable). Synchronous requests must complete within 10s. If either querying or enrichment exceeds 10s, please use the async option.

        Parameters
        ----------
        id : str

        async_ : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ModelSampleResponseEnvelope
            OK

        Examples
        --------
        import asyncio

        from polytomic import AsyncPolytomic

        client = AsyncPolytomic(
            version="YOUR_VERSION",
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.models.sample(
                id="248df4b7-aa70-47b8-a036-33ac447e668d",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/models/{jsonable_encoder(id)}/sample",
            method="GET",
            params={
                "async": async_,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ModelSampleResponseEnvelope,
                    parse_obj_as(
                        type_=ModelSampleResponseEnvelope,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(
                        RestErrResponse,
                        parse_obj_as(
                            type_=RestErrResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(status_code=_response.status_code, body=_response.text)
        raise core_api_error_ApiError(status_code=_response.status_code, body=_response_json)
